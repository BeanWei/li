// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/json"
	"fmt"
	"reflect"
	"strings"

	"entgo.io/ent/dialect/sql"
	"github.com/BeanWei/li/li-engine/ac"
	"github.com/BeanWei/li/li-engine/contrib/liflow/ent/flowdefinition"
	"github.com/BeanWei/li/li-engine/contrib/liflow/ent/flowdeployment"
	"github.com/BeanWei/li/li-engine/contrib/liflow/ent/schema"
	"github.com/BeanWei/li/li-engine/view"
	"github.com/BeanWei/li/li-engine/view/node"
	"github.com/gogf/gf/v2/errors/gcode"
	"github.com/gogf/gf/v2/errors/gerror"
)

// FlowDeployment is the model entity for the FlowDeployment schema.
type FlowDeployment struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt int64 `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt int64 `json:"updated_at,omitempty"`
	// DeletedAt holds the value of the "deleted_at" field.
	DeletedAt int64 `json:"-"`
	// FlowDefinitionID holds the value of the "flow_definition_id" field.
	// 流程定义ID
	FlowDefinitionID string `json:"flow_definition_id,omitempty"`
	// Name holds the value of the "name" field.
	// 流程名称
	Name string `json:"name,omitempty"`
	// Status holds the value of the "status" field.
	// 状态(1.已部署 2.已下线)
	Status int8 `json:"status,omitempty"`
	// Model holds the value of the "model" field.
	// 流程模型
	Model schema.FlowModel `json:"model,omitempty"`
	// Remark holds the value of the "remark" field.
	// 备注
	Remark string `json:"remark,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the FlowDeploymentQuery when eager-loading is set.
	Edges FlowDeploymentEdges `json:"edges"`
}

// FlowDeploymentEdges holds the relations/edges for other nodes in the graph.
type FlowDeploymentEdges struct {
	// FlowDefinition holds the value of the flow_definition edge.
	FlowDefinition *FlowDefinition `json:"flow_definition,omitempty"`
	// FlowInstances holds the value of the flow_instances edge.
	FlowInstances []*FlowInstance `json:"flow_instances,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [2]bool
}

// FlowDefinitionOrErr returns the FlowDefinition value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e FlowDeploymentEdges) FlowDefinitionOrErr() (*FlowDefinition, error) {
	if e.loadedTypes[0] {
		if e.FlowDefinition == nil {
			// The edge flow_definition was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: flowdefinition.Label}
		}
		return e.FlowDefinition, nil
	}
	return nil, &NotLoadedError{edge: "flow_definition"}
}

// FlowInstancesOrErr returns the FlowInstances value or an error if the edge
// was not loaded in eager-loading.
func (e FlowDeploymentEdges) FlowInstancesOrErr() ([]*FlowInstance, error) {
	if e.loadedTypes[1] {
		return e.FlowInstances, nil
	}
	return nil, &NotLoadedError{edge: "flow_instances"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*FlowDeployment) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case flowdeployment.FieldModel:
			values[i] = new([]byte)
		case flowdeployment.FieldCreatedAt, flowdeployment.FieldUpdatedAt, flowdeployment.FieldDeletedAt, flowdeployment.FieldStatus:
			values[i] = new(sql.NullInt64)
		case flowdeployment.FieldID, flowdeployment.FieldFlowDefinitionID, flowdeployment.FieldName, flowdeployment.FieldRemark:
			values[i] = new(sql.NullString)
		default:
			return nil, fmt.Errorf("unexpected column %q for type FlowDeployment", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the FlowDeployment fields.
func (fd *FlowDeployment) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case flowdeployment.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				fd.ID = value.String
			}
		case flowdeployment.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				fd.CreatedAt = value.Int64
			}
		case flowdeployment.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				fd.UpdatedAt = value.Int64
			}
		case flowdeployment.FieldDeletedAt:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field deleted_at", values[i])
			} else if value.Valid {
				fd.DeletedAt = value.Int64
			}
		case flowdeployment.FieldFlowDefinitionID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field flow_definition_id", values[i])
			} else if value.Valid {
				fd.FlowDefinitionID = value.String
			}
		case flowdeployment.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				fd.Name = value.String
			}
		case flowdeployment.FieldStatus:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field status", values[i])
			} else if value.Valid {
				fd.Status = int8(value.Int64)
			}
		case flowdeployment.FieldModel:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field model", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &fd.Model); err != nil {
					return fmt.Errorf("unmarshal field model: %w", err)
				}
			}
		case flowdeployment.FieldRemark:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field remark", values[i])
			} else if value.Valid {
				fd.Remark = value.String
			}
		}
	}
	return nil
}

// QueryFlowDefinition queries the "flow_definition" edge of the FlowDeployment entity.
func (fd *FlowDeployment) QueryFlowDefinition() *FlowDefinitionQuery {
	return (&FlowDeploymentClient{config: fd.config}).QueryFlowDefinition(fd)
}

// QueryFlowInstances queries the "flow_instances" edge of the FlowDeployment entity.
func (fd *FlowDeployment) QueryFlowInstances() *FlowInstanceQuery {
	return (&FlowDeploymentClient{config: fd.config}).QueryFlowInstances(fd)
}

// Update returns a builder for updating this FlowDeployment.
// Note that you need to call FlowDeployment.Unwrap() before calling this method if this FlowDeployment
// was returned from a transaction, and the transaction was committed or rolled back.
func (fd *FlowDeployment) Update() *FlowDeploymentUpdateOne {
	return (&FlowDeploymentClient{config: fd.config}).UpdateOne(fd)
}

// Unwrap unwraps the FlowDeployment entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (fd *FlowDeployment) Unwrap() *FlowDeployment {
	tx, ok := fd.config.driver.(*txDriver)
	if !ok {
		panic("ent: FlowDeployment is not a transactional entity")
	}
	fd.config.driver = tx.drv
	return fd
}

// String implements the fmt.Stringer.
func (fd *FlowDeployment) String() string {
	var builder strings.Builder
	builder.WriteString("FlowDeployment(")
	builder.WriteString(fmt.Sprintf("id=%v", fd.ID))
	builder.WriteString(", created_at=")
	builder.WriteString(fmt.Sprintf("%v", fd.CreatedAt))
	builder.WriteString(", updated_at=")
	builder.WriteString(fmt.Sprintf("%v", fd.UpdatedAt))
	builder.WriteString(", deleted_at=")
	builder.WriteString(fmt.Sprintf("%v", fd.DeletedAt))
	builder.WriteString(", flow_definition_id=")
	builder.WriteString(fd.FlowDefinitionID)
	builder.WriteString(", name=")
	builder.WriteString(fd.Name)
	builder.WriteString(", status=")
	builder.WriteString(fmt.Sprintf("%v", fd.Status))
	builder.WriteString(", model=")
	builder.WriteString(fmt.Sprintf("%v", fd.Model))
	builder.WriteString(", remark=")
	builder.WriteString(fd.Remark)
	builder.WriteByte(')')
	return builder.String()
}

type (
	IFlowDeployment struct {
		ID               string           `json:"id,omitempty"`
		CreatedAt        int64            `json:"created_at,omitempty"`
		UpdatedAt        int64            `json:"updated_at,omitempty"`
		DeletedAt        int64            `json:"-"`
		FlowDefinitionID string           `json:"flow_definition_id,omitempty"`
		Name             string           `json:"name,omitempty"`
		Status           int8             `json:"status,omitempty"`
		Model            schema.FlowModel `json:"model,omitempty"`
		Remark           string           `json:"remark,omitempty"`
		FlowDefinition   *IFlowDefinition `json:"flow_definition,omitempty"`
		FlowInstances    []*IFlowInstance `json:"flow_instances,omitempty"`
	}
	ListFlowDeploymentReq struct {
		Page   int                       `json:"page" d:"1" v:"min:1"`
		Limit  int                       `json:"limit" d:"20" v:"min:1|max:500"`
		Query  string                    `json:"query"`
		Filter *ListFlowDeploymentFilter `json:"filter"`
		Sorter *ListFlowDeploymentSorter `json:"sorter"`
	}
	ListFlowDeploymentFilter struct {
	}
	ListFlowDeploymentSorter struct {
	}
	ListFlowDeploymentRes struct {
		List  []*IFlowDeployment `json:"list"`
		Total int                `json:"total"`
	}
	CreateFlowDeploymentReq struct {
	}
	GetFlowDeploymentReq struct {
		ID string `json:"id" v:"required"`
	}
	UpdateFlowDeploymentReq struct {
		ID string `json:"id" v:"required"`
	}
	DeleteFlowDeploymentReq struct {
		ID string `json:"id" v:"required"`
	}
	DeleteManyFlowDeploymentReq struct {
		IDs []string `json:"ids" v:"required"`
	}
)

func NewIFlowDeployment(e *FlowDeployment) *IFlowDeployment {
	if e == nil {
		return nil
	}
	return &IFlowDeployment{
		ID:               e.ID,
		CreatedAt:        e.CreatedAt,
		UpdatedAt:        e.UpdatedAt,
		DeletedAt:        e.DeletedAt,
		FlowDefinitionID: e.FlowDefinitionID,
		Name:             e.Name,
		Status:           e.Status,
		Model:            e.Model,
		Remark:           e.Remark,
		FlowDefinition:   NewIFlowDefinition(e.Edges.FlowDefinition),
		FlowInstances:    NewIFlowInstanceArray(e.Edges.FlowInstances),
	}
}

func NewIFlowDeploymentArray(es []*FlowDeployment) []*IFlowDeployment {
	if len(es) == 0 {
		return nil
	}
	r := make([]*IFlowDeployment, len(es))
	for i, e := range es {
		r[i] = NewIFlowDeployment(e)
	}
	return r
}

func ListFlowDeploymentController(ctx context.Context, req *ListFlowDeploymentReq) (res *ListFlowDeploymentRes, err error) {
	q := DB().FlowDeployment.Query()
	if req.Filter != nil {
	}
	res = &ListFlowDeploymentRes{}
	res.Total, err = q.Count(ctx)
	if err != nil {
		return nil, gerror.WrapCode(gcode.CodeDbOperationError, err)
	}
	ret, err := q.Limit(req.Limit).Offset((req.Page - 1) * req.Limit).All(ctx)
	if err != nil {
		return nil, gerror.WrapCode(gcode.CodeDbOperationError, err)
	}
	res.List = NewIFlowDeploymentArray(ret)
	return res, nil
}

func CreateFlowDeploymentController(ctx context.Context, req *CreateFlowDeploymentReq) (err error) {
	b := DB().FlowDeployment.Create()
	err = b.Exec(ctx)
	if err != nil {
		if IsConstraintError(err) {
			return gerror.WrapCode(gcode.CodeOperationFailed, err)
		}
		return gerror.WrapCode(gcode.CodeDbOperationError, err)
	}
	return
}

func GetFlowDeploymentController(ctx context.Context, req *GetFlowDeploymentReq) (res *IFlowDeployment, err error) {
	ret, err := DB().FlowDeployment.
		Query().
		Where(flowdeployment.IDEQ(req.ID)).
		Only(ctx)
	if err != nil {
		if IsNotFound(err) {
			return nil, gerror.WrapCode(gcode.CodeNotFound, err)
		}
		return nil, gerror.WrapCode(gcode.CodeDbOperationError, err)
	}
	return NewIFlowDeployment(ret), nil
}

func UpdateFlowDeploymentController(ctx context.Context, req *UpdateFlowDeploymentReq) (err error) {
	b := DB().FlowDeployment.UpdateOneID(req.ID)
	err = b.Exec(ctx)
	if err != nil {
		if IsNotFound(err) {
			return gerror.WrapCode(gcode.CodeNotFound, err)
		} else if IsConstraintError(err) {
			return gerror.WrapCode(gcode.CodeOperationFailed, err)
		}
		return gerror.WrapCode(gcode.CodeDbOperationError, err)
	}
	return
}

func DeleteFlowDeploymentController(ctx context.Context, req *DeleteFlowDeploymentReq) (err error) {
	err = DB().FlowDeployment.DeleteOneID(req.ID).Exec(ctx)
	if err != nil {
		if IsNotFound(err) {
			return gerror.WrapCode(gcode.CodeNotFound, err)
		} else if IsConstraintError(err) {
			return gerror.WrapCode(gcode.CodeOperationFailed, err)
		}
		return gerror.WrapCode(gcode.CodeDbOperationError, err)
	}
	return
}

func DeleteManyFlowDeploymentController(ctx context.Context, req *DeleteManyFlowDeploymentReq) (err error) {
	_, err = DB().FlowDeployment.Delete().Where(flowdeployment.IDIn(req.IDs...)).Exec(ctx)
	if err != nil {
		return gerror.WrapCode(gcode.CodeDbOperationError, err)
	}
	return
}

func CreateFlowDeploymentFormView() view.Node {
	return node.FormGrid("grid").MaxColumns(2).Children()
}

func ReadFlowDeploymentFormView() view.Node {
	return node.FormGrid("grid").MaxColumns(2).Children()
}

func UpdateFlowDeploymentFormView() view.Node {
	return node.FormGrid("grid").MaxColumns(2).Children()
}

func ListFlowDeploymentTableColumns() []view.Node {
	return []view.Node{}
}

func ListFlowDeploymentView() view.Node {
	return node.List("flowdeploymentList").
		AC(flowdeploymentViewACL["list:FlowDeployment"]).
		ForInit("@listFlowDeployment", ListFlowDeploymentController).
		DecoratorCard().
		EnableFilter().
		SelectionMultiple(true).
		Children(
			node.ListTable("flowdeploymentListTable").
				ActionBar(
					node.ListAction("flowdeploymentListActions").Children(
						node.ListActionRecordFormDrawer("addFlowDeployment").
							Title("addNew").
							AC(flowdeploymentViewACL["create:FlowDeployment"]).
							ButtonType("primary").
							ButtonIcon("IconPlus").
							ButtonPosition("left").
							Body(CreateFlowDeploymentFormView()).
							Footer(
								node.ActionFormDrawerCancel("cancel"),
								node.ActionFormDrawerSubmit("submit").ForSubmit("@addFlowDeployment", CreateFlowDeploymentController),
							),
						node.ListActionRowSelection("deleteManyFlowDeployment").
							Title("bulkDelete").
							AC(flowdeploymentViewACL["deleteMany:FlowDeployment"]).
							ForSubmit("@deleteManyFlowDeployment", DeleteManyFlowDeploymentController).
							AfterReload(true).
							ConfirmTitle("confirmDelete").
							ButtonStatus("danger").
							ButtonIcon("IconDelete").
							ButtonPosition("left"),
					),
				).
				Columns(
					append(
						ListFlowDeploymentTableColumns(),
						node.ListTableColumn("columnAction").
							Title("columnAction").
							DataIndex("__action").
							Width(150).
							Render(
								node.Space("actions").Size(0).SplitByDivider().Children(
									node.ListActionRecordFormDrawer("view").
										AC(flowdeploymentViewACL["get:FlowDeployment"]).
										ForInit("@getFlowDeployment", GetFlowDeploymentController).
										DrawerTitle("viewDrawerTitle").
										ButtonType("text").
										ButtonIcon("IconEye").
										Body(ReadFlowDeploymentFormView()).
										Footer(
											node.ActionFormDrawerCancel("cancel"),
										),
									node.ListActionRecordFormDrawer("edit").
										AC(flowdeploymentViewACL["update:FlowDeployment"]).
										ForInit("@getFlowDeployment", GetFlowDeploymentController).
										DrawerTitle("editDrawerTitle").
										ButtonType("text").
										ButtonIcon("IconEdit").
										Body(UpdateFlowDeploymentFormView()).
										Footer(
											node.ActionFormDrawerCancel("cancel"),
											node.ActionFormDrawerSubmit("submit").
												ForSubmit("@updateFlowDeployment", UpdateFlowDeploymentController),
										),
									node.ListActionRecordDelete("delete").
										AC(flowdeploymentViewACL["delete:FlowDeployment"]).
										ForSubmit("@deleteFlowDeployment", DeleteFlowDeploymentController).
										ButtonType("text").
										ButtonIcon("IconDelete"),
								),
							),
					)...,
				),
		)
}

var flowdeploymentViewACL = map[string]ac.AC{}

func init() {
	rf := reflect.ValueOf(schema.FlowDeployment{}).MethodByName("ACL")
	if rf.IsValid() {
		flowdeploymentViewACL, _ = rf.Call([]reflect.Value{})[0].Interface().(map[string]ac.AC)
	}
}

// FlowDeployments is a parsable slice of FlowDeployment.
type FlowDeployments []*FlowDeployment

func (fd FlowDeployments) config(cfg config) {
	for _i := range fd {
		fd[_i].config = cfg
	}
}
