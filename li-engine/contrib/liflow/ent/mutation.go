// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"github.com/BeanWei/li/li-engine/contrib/liflow/ent/flowdefinition"
	"github.com/BeanWei/li/li-engine/contrib/liflow/ent/flowdeployment"
	"github.com/BeanWei/li/li-engine/contrib/liflow/ent/flowinstance"
	"github.com/BeanWei/li/li-engine/contrib/liflow/ent/flowinstancedata"
	"github.com/BeanWei/li/li-engine/contrib/liflow/ent/flownodeinstance"
	"github.com/BeanWei/li/li-engine/contrib/liflow/ent/flownodeinstancelog"
	"github.com/BeanWei/li/li-engine/contrib/liflow/ent/predicate"
	"github.com/BeanWei/li/li-engine/contrib/liflow/ent/schema"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeFlowDefinition      = "FlowDefinition"
	TypeFlowDeployment      = "FlowDeployment"
	TypeFlowInstance        = "FlowInstance"
	TypeFlowInstanceData    = "FlowInstanceData"
	TypeFlowNodeInstance    = "FlowNodeInstance"
	TypeFlowNodeInstanceLog = "FlowNodeInstanceLog"
)

// FlowDefinitionMutation represents an operation that mutates the FlowDefinition nodes in the graph.
type FlowDefinitionMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	created_at              *int64
	addcreated_at           *int64
	updated_at              *int64
	addupdated_at           *int64
	deleted_at              *int64
	adddeleted_at           *int64
	name                    *string
	status                  *int8
	addstatus               *int8
	model                   *schema.FlowModel
	remark                  *string
	clearedFields           map[string]struct{}
	flow_deployments        map[string]struct{}
	removedflow_deployments map[string]struct{}
	clearedflow_deployments bool
	done                    bool
	oldValue                func(context.Context) (*FlowDefinition, error)
	predicates              []predicate.FlowDefinition
}

var _ ent.Mutation = (*FlowDefinitionMutation)(nil)

// flowdefinitionOption allows management of the mutation configuration using functional options.
type flowdefinitionOption func(*FlowDefinitionMutation)

// newFlowDefinitionMutation creates new mutation for the FlowDefinition entity.
func newFlowDefinitionMutation(c config, op Op, opts ...flowdefinitionOption) *FlowDefinitionMutation {
	m := &FlowDefinitionMutation{
		config:        c,
		op:            op,
		typ:           TypeFlowDefinition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFlowDefinitionID sets the ID field of the mutation.
func withFlowDefinitionID(id string) flowdefinitionOption {
	return func(m *FlowDefinitionMutation) {
		var (
			err   error
			once  sync.Once
			value *FlowDefinition
		)
		m.oldValue = func(ctx context.Context) (*FlowDefinition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FlowDefinition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFlowDefinition sets the old FlowDefinition of the mutation.
func withFlowDefinition(node *FlowDefinition) flowdefinitionOption {
	return func(m *FlowDefinitionMutation) {
		m.oldValue = func(context.Context) (*FlowDefinition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FlowDefinitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FlowDefinitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FlowDefinition entities.
func (m *FlowDefinitionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FlowDefinitionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FlowDefinitionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FlowDefinition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FlowDefinitionMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FlowDefinitionMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FlowDefinition entity.
// If the FlowDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowDefinitionMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *FlowDefinitionMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *FlowDefinitionMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FlowDefinitionMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FlowDefinitionMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FlowDefinitionMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FlowDefinition entity.
// If the FlowDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowDefinitionMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *FlowDefinitionMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *FlowDefinitionMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FlowDefinitionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FlowDefinitionMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FlowDefinitionMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FlowDefinition entity.
// If the FlowDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowDefinitionMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *FlowDefinitionMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *FlowDefinitionMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FlowDefinitionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
	m.clearedFields[flowdefinition.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FlowDefinitionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[flowdefinition.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FlowDefinitionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
	delete(m.clearedFields, flowdefinition.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *FlowDefinitionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FlowDefinitionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the FlowDefinition entity.
// If the FlowDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowDefinitionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FlowDefinitionMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *FlowDefinitionMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *FlowDefinitionMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the FlowDefinition entity.
// If the FlowDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowDefinitionMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *FlowDefinitionMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *FlowDefinitionMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *FlowDefinitionMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetModel sets the "model" field.
func (m *FlowDefinitionMutation) SetModel(sm schema.FlowModel) {
	m.model = &sm
}

// Model returns the value of the "model" field in the mutation.
func (m *FlowDefinitionMutation) Model() (r schema.FlowModel, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the FlowDefinition entity.
// If the FlowDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowDefinitionMutation) OldModel(ctx context.Context) (v schema.FlowModel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *FlowDefinitionMutation) ResetModel() {
	m.model = nil
}

// SetRemark sets the "remark" field.
func (m *FlowDefinitionMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *FlowDefinitionMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the FlowDefinition entity.
// If the FlowDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowDefinitionMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *FlowDefinitionMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[flowdefinition.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *FlowDefinitionMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[flowdefinition.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *FlowDefinitionMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, flowdefinition.FieldRemark)
}

// AddFlowDeploymentIDs adds the "flow_deployments" edge to the FlowDeployment entity by ids.
func (m *FlowDefinitionMutation) AddFlowDeploymentIDs(ids ...string) {
	if m.flow_deployments == nil {
		m.flow_deployments = make(map[string]struct{})
	}
	for i := range ids {
		m.flow_deployments[ids[i]] = struct{}{}
	}
}

// ClearFlowDeployments clears the "flow_deployments" edge to the FlowDeployment entity.
func (m *FlowDefinitionMutation) ClearFlowDeployments() {
	m.clearedflow_deployments = true
}

// FlowDeploymentsCleared reports if the "flow_deployments" edge to the FlowDeployment entity was cleared.
func (m *FlowDefinitionMutation) FlowDeploymentsCleared() bool {
	return m.clearedflow_deployments
}

// RemoveFlowDeploymentIDs removes the "flow_deployments" edge to the FlowDeployment entity by IDs.
func (m *FlowDefinitionMutation) RemoveFlowDeploymentIDs(ids ...string) {
	if m.removedflow_deployments == nil {
		m.removedflow_deployments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.flow_deployments, ids[i])
		m.removedflow_deployments[ids[i]] = struct{}{}
	}
}

// RemovedFlowDeployments returns the removed IDs of the "flow_deployments" edge to the FlowDeployment entity.
func (m *FlowDefinitionMutation) RemovedFlowDeploymentsIDs() (ids []string) {
	for id := range m.removedflow_deployments {
		ids = append(ids, id)
	}
	return
}

// FlowDeploymentsIDs returns the "flow_deployments" edge IDs in the mutation.
func (m *FlowDefinitionMutation) FlowDeploymentsIDs() (ids []string) {
	for id := range m.flow_deployments {
		ids = append(ids, id)
	}
	return
}

// ResetFlowDeployments resets all changes to the "flow_deployments" edge.
func (m *FlowDefinitionMutation) ResetFlowDeployments() {
	m.flow_deployments = nil
	m.clearedflow_deployments = false
	m.removedflow_deployments = nil
}

// Where appends a list predicates to the FlowDefinitionMutation builder.
func (m *FlowDefinitionMutation) Where(ps ...predicate.FlowDefinition) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FlowDefinitionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FlowDefinition).
func (m *FlowDefinitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FlowDefinitionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, flowdefinition.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, flowdefinition.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, flowdefinition.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, flowdefinition.FieldName)
	}
	if m.status != nil {
		fields = append(fields, flowdefinition.FieldStatus)
	}
	if m.model != nil {
		fields = append(fields, flowdefinition.FieldModel)
	}
	if m.remark != nil {
		fields = append(fields, flowdefinition.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FlowDefinitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flowdefinition.FieldCreatedAt:
		return m.CreatedAt()
	case flowdefinition.FieldUpdatedAt:
		return m.UpdatedAt()
	case flowdefinition.FieldDeletedAt:
		return m.DeletedAt()
	case flowdefinition.FieldName:
		return m.Name()
	case flowdefinition.FieldStatus:
		return m.Status()
	case flowdefinition.FieldModel:
		return m.Model()
	case flowdefinition.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FlowDefinitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flowdefinition.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case flowdefinition.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case flowdefinition.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case flowdefinition.FieldName:
		return m.OldName(ctx)
	case flowdefinition.FieldStatus:
		return m.OldStatus(ctx)
	case flowdefinition.FieldModel:
		return m.OldModel(ctx)
	case flowdefinition.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown FlowDefinition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlowDefinitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flowdefinition.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case flowdefinition.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case flowdefinition.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case flowdefinition.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case flowdefinition.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case flowdefinition.FieldModel:
		v, ok := value.(schema.FlowModel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case flowdefinition.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown FlowDefinition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FlowDefinitionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, flowdefinition.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, flowdefinition.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, flowdefinition.FieldDeletedAt)
	}
	if m.addstatus != nil {
		fields = append(fields, flowdefinition.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FlowDefinitionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case flowdefinition.FieldCreatedAt:
		return m.AddedCreatedAt()
	case flowdefinition.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case flowdefinition.FieldDeletedAt:
		return m.AddedDeletedAt()
	case flowdefinition.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlowDefinitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case flowdefinition.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case flowdefinition.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case flowdefinition.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case flowdefinition.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown FlowDefinition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FlowDefinitionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(flowdefinition.FieldDeletedAt) {
		fields = append(fields, flowdefinition.FieldDeletedAt)
	}
	if m.FieldCleared(flowdefinition.FieldRemark) {
		fields = append(fields, flowdefinition.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FlowDefinitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FlowDefinitionMutation) ClearField(name string) error {
	switch name {
	case flowdefinition.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case flowdefinition.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown FlowDefinition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FlowDefinitionMutation) ResetField(name string) error {
	switch name {
	case flowdefinition.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case flowdefinition.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case flowdefinition.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case flowdefinition.FieldName:
		m.ResetName()
		return nil
	case flowdefinition.FieldStatus:
		m.ResetStatus()
		return nil
	case flowdefinition.FieldModel:
		m.ResetModel()
		return nil
	case flowdefinition.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown FlowDefinition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FlowDefinitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.flow_deployments != nil {
		edges = append(edges, flowdefinition.EdgeFlowDeployments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FlowDefinitionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case flowdefinition.EdgeFlowDeployments:
		ids := make([]ent.Value, 0, len(m.flow_deployments))
		for id := range m.flow_deployments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FlowDefinitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedflow_deployments != nil {
		edges = append(edges, flowdefinition.EdgeFlowDeployments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FlowDefinitionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case flowdefinition.EdgeFlowDeployments:
		ids := make([]ent.Value, 0, len(m.removedflow_deployments))
		for id := range m.removedflow_deployments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FlowDefinitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedflow_deployments {
		edges = append(edges, flowdefinition.EdgeFlowDeployments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FlowDefinitionMutation) EdgeCleared(name string) bool {
	switch name {
	case flowdefinition.EdgeFlowDeployments:
		return m.clearedflow_deployments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FlowDefinitionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown FlowDefinition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FlowDefinitionMutation) ResetEdge(name string) error {
	switch name {
	case flowdefinition.EdgeFlowDeployments:
		m.ResetFlowDeployments()
		return nil
	}
	return fmt.Errorf("unknown FlowDefinition edge %s", name)
}

// FlowDeploymentMutation represents an operation that mutates the FlowDeployment nodes in the graph.
type FlowDeploymentMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	created_at             *int64
	addcreated_at          *int64
	updated_at             *int64
	addupdated_at          *int64
	deleted_at             *int64
	adddeleted_at          *int64
	name                   *string
	status                 *int8
	addstatus              *int8
	model                  *schema.FlowModel
	remark                 *string
	clearedFields          map[string]struct{}
	flow_definition        *string
	clearedflow_definition bool
	flow_instances         map[string]struct{}
	removedflow_instances  map[string]struct{}
	clearedflow_instances  bool
	done                   bool
	oldValue               func(context.Context) (*FlowDeployment, error)
	predicates             []predicate.FlowDeployment
}

var _ ent.Mutation = (*FlowDeploymentMutation)(nil)

// flowdeploymentOption allows management of the mutation configuration using functional options.
type flowdeploymentOption func(*FlowDeploymentMutation)

// newFlowDeploymentMutation creates new mutation for the FlowDeployment entity.
func newFlowDeploymentMutation(c config, op Op, opts ...flowdeploymentOption) *FlowDeploymentMutation {
	m := &FlowDeploymentMutation{
		config:        c,
		op:            op,
		typ:           TypeFlowDeployment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFlowDeploymentID sets the ID field of the mutation.
func withFlowDeploymentID(id string) flowdeploymentOption {
	return func(m *FlowDeploymentMutation) {
		var (
			err   error
			once  sync.Once
			value *FlowDeployment
		)
		m.oldValue = func(ctx context.Context) (*FlowDeployment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FlowDeployment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFlowDeployment sets the old FlowDeployment of the mutation.
func withFlowDeployment(node *FlowDeployment) flowdeploymentOption {
	return func(m *FlowDeploymentMutation) {
		m.oldValue = func(context.Context) (*FlowDeployment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FlowDeploymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FlowDeploymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FlowDeployment entities.
func (m *FlowDeploymentMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FlowDeploymentMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FlowDeploymentMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FlowDeployment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FlowDeploymentMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FlowDeploymentMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FlowDeployment entity.
// If the FlowDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowDeploymentMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *FlowDeploymentMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *FlowDeploymentMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FlowDeploymentMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FlowDeploymentMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FlowDeploymentMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FlowDeployment entity.
// If the FlowDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowDeploymentMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *FlowDeploymentMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *FlowDeploymentMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FlowDeploymentMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FlowDeploymentMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FlowDeploymentMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FlowDeployment entity.
// If the FlowDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowDeploymentMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *FlowDeploymentMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *FlowDeploymentMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FlowDeploymentMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
	m.clearedFields[flowdeployment.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FlowDeploymentMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[flowdeployment.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FlowDeploymentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
	delete(m.clearedFields, flowdeployment.FieldDeletedAt)
}

// SetFlowDefinitionID sets the "flow_definition_id" field.
func (m *FlowDeploymentMutation) SetFlowDefinitionID(s string) {
	m.flow_definition = &s
}

// FlowDefinitionID returns the value of the "flow_definition_id" field in the mutation.
func (m *FlowDeploymentMutation) FlowDefinitionID() (r string, exists bool) {
	v := m.flow_definition
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowDefinitionID returns the old "flow_definition_id" field's value of the FlowDeployment entity.
// If the FlowDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowDeploymentMutation) OldFlowDefinitionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowDefinitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowDefinitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowDefinitionID: %w", err)
	}
	return oldValue.FlowDefinitionID, nil
}

// ResetFlowDefinitionID resets all changes to the "flow_definition_id" field.
func (m *FlowDeploymentMutation) ResetFlowDefinitionID() {
	m.flow_definition = nil
}

// SetName sets the "name" field.
func (m *FlowDeploymentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FlowDeploymentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the FlowDeployment entity.
// If the FlowDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowDeploymentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FlowDeploymentMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *FlowDeploymentMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *FlowDeploymentMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the FlowDeployment entity.
// If the FlowDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowDeploymentMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *FlowDeploymentMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *FlowDeploymentMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *FlowDeploymentMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetModel sets the "model" field.
func (m *FlowDeploymentMutation) SetModel(sm schema.FlowModel) {
	m.model = &sm
}

// Model returns the value of the "model" field in the mutation.
func (m *FlowDeploymentMutation) Model() (r schema.FlowModel, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the FlowDeployment entity.
// If the FlowDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowDeploymentMutation) OldModel(ctx context.Context) (v schema.FlowModel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *FlowDeploymentMutation) ResetModel() {
	m.model = nil
}

// SetRemark sets the "remark" field.
func (m *FlowDeploymentMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *FlowDeploymentMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the FlowDeployment entity.
// If the FlowDeployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowDeploymentMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *FlowDeploymentMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[flowdeployment.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *FlowDeploymentMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[flowdeployment.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *FlowDeploymentMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, flowdeployment.FieldRemark)
}

// ClearFlowDefinition clears the "flow_definition" edge to the FlowDefinition entity.
func (m *FlowDeploymentMutation) ClearFlowDefinition() {
	m.clearedflow_definition = true
}

// FlowDefinitionCleared reports if the "flow_definition" edge to the FlowDefinition entity was cleared.
func (m *FlowDeploymentMutation) FlowDefinitionCleared() bool {
	return m.clearedflow_definition
}

// FlowDefinitionIDs returns the "flow_definition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FlowDefinitionID instead. It exists only for internal usage by the builders.
func (m *FlowDeploymentMutation) FlowDefinitionIDs() (ids []string) {
	if id := m.flow_definition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFlowDefinition resets all changes to the "flow_definition" edge.
func (m *FlowDeploymentMutation) ResetFlowDefinition() {
	m.flow_definition = nil
	m.clearedflow_definition = false
}

// AddFlowInstanceIDs adds the "flow_instances" edge to the FlowInstance entity by ids.
func (m *FlowDeploymentMutation) AddFlowInstanceIDs(ids ...string) {
	if m.flow_instances == nil {
		m.flow_instances = make(map[string]struct{})
	}
	for i := range ids {
		m.flow_instances[ids[i]] = struct{}{}
	}
}

// ClearFlowInstances clears the "flow_instances" edge to the FlowInstance entity.
func (m *FlowDeploymentMutation) ClearFlowInstances() {
	m.clearedflow_instances = true
}

// FlowInstancesCleared reports if the "flow_instances" edge to the FlowInstance entity was cleared.
func (m *FlowDeploymentMutation) FlowInstancesCleared() bool {
	return m.clearedflow_instances
}

// RemoveFlowInstanceIDs removes the "flow_instances" edge to the FlowInstance entity by IDs.
func (m *FlowDeploymentMutation) RemoveFlowInstanceIDs(ids ...string) {
	if m.removedflow_instances == nil {
		m.removedflow_instances = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.flow_instances, ids[i])
		m.removedflow_instances[ids[i]] = struct{}{}
	}
}

// RemovedFlowInstances returns the removed IDs of the "flow_instances" edge to the FlowInstance entity.
func (m *FlowDeploymentMutation) RemovedFlowInstancesIDs() (ids []string) {
	for id := range m.removedflow_instances {
		ids = append(ids, id)
	}
	return
}

// FlowInstancesIDs returns the "flow_instances" edge IDs in the mutation.
func (m *FlowDeploymentMutation) FlowInstancesIDs() (ids []string) {
	for id := range m.flow_instances {
		ids = append(ids, id)
	}
	return
}

// ResetFlowInstances resets all changes to the "flow_instances" edge.
func (m *FlowDeploymentMutation) ResetFlowInstances() {
	m.flow_instances = nil
	m.clearedflow_instances = false
	m.removedflow_instances = nil
}

// Where appends a list predicates to the FlowDeploymentMutation builder.
func (m *FlowDeploymentMutation) Where(ps ...predicate.FlowDeployment) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FlowDeploymentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FlowDeployment).
func (m *FlowDeploymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FlowDeploymentMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, flowdeployment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, flowdeployment.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, flowdeployment.FieldDeletedAt)
	}
	if m.flow_definition != nil {
		fields = append(fields, flowdeployment.FieldFlowDefinitionID)
	}
	if m.name != nil {
		fields = append(fields, flowdeployment.FieldName)
	}
	if m.status != nil {
		fields = append(fields, flowdeployment.FieldStatus)
	}
	if m.model != nil {
		fields = append(fields, flowdeployment.FieldModel)
	}
	if m.remark != nil {
		fields = append(fields, flowdeployment.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FlowDeploymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flowdeployment.FieldCreatedAt:
		return m.CreatedAt()
	case flowdeployment.FieldUpdatedAt:
		return m.UpdatedAt()
	case flowdeployment.FieldDeletedAt:
		return m.DeletedAt()
	case flowdeployment.FieldFlowDefinitionID:
		return m.FlowDefinitionID()
	case flowdeployment.FieldName:
		return m.Name()
	case flowdeployment.FieldStatus:
		return m.Status()
	case flowdeployment.FieldModel:
		return m.Model()
	case flowdeployment.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FlowDeploymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flowdeployment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case flowdeployment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case flowdeployment.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case flowdeployment.FieldFlowDefinitionID:
		return m.OldFlowDefinitionID(ctx)
	case flowdeployment.FieldName:
		return m.OldName(ctx)
	case flowdeployment.FieldStatus:
		return m.OldStatus(ctx)
	case flowdeployment.FieldModel:
		return m.OldModel(ctx)
	case flowdeployment.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown FlowDeployment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlowDeploymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flowdeployment.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case flowdeployment.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case flowdeployment.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case flowdeployment.FieldFlowDefinitionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowDefinitionID(v)
		return nil
	case flowdeployment.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case flowdeployment.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case flowdeployment.FieldModel:
		v, ok := value.(schema.FlowModel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case flowdeployment.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown FlowDeployment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FlowDeploymentMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, flowdeployment.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, flowdeployment.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, flowdeployment.FieldDeletedAt)
	}
	if m.addstatus != nil {
		fields = append(fields, flowdeployment.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FlowDeploymentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case flowdeployment.FieldCreatedAt:
		return m.AddedCreatedAt()
	case flowdeployment.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case flowdeployment.FieldDeletedAt:
		return m.AddedDeletedAt()
	case flowdeployment.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlowDeploymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case flowdeployment.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case flowdeployment.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case flowdeployment.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case flowdeployment.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown FlowDeployment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FlowDeploymentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(flowdeployment.FieldDeletedAt) {
		fields = append(fields, flowdeployment.FieldDeletedAt)
	}
	if m.FieldCleared(flowdeployment.FieldRemark) {
		fields = append(fields, flowdeployment.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FlowDeploymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FlowDeploymentMutation) ClearField(name string) error {
	switch name {
	case flowdeployment.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case flowdeployment.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown FlowDeployment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FlowDeploymentMutation) ResetField(name string) error {
	switch name {
	case flowdeployment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case flowdeployment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case flowdeployment.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case flowdeployment.FieldFlowDefinitionID:
		m.ResetFlowDefinitionID()
		return nil
	case flowdeployment.FieldName:
		m.ResetName()
		return nil
	case flowdeployment.FieldStatus:
		m.ResetStatus()
		return nil
	case flowdeployment.FieldModel:
		m.ResetModel()
		return nil
	case flowdeployment.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown FlowDeployment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FlowDeploymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.flow_definition != nil {
		edges = append(edges, flowdeployment.EdgeFlowDefinition)
	}
	if m.flow_instances != nil {
		edges = append(edges, flowdeployment.EdgeFlowInstances)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FlowDeploymentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case flowdeployment.EdgeFlowDefinition:
		if id := m.flow_definition; id != nil {
			return []ent.Value{*id}
		}
	case flowdeployment.EdgeFlowInstances:
		ids := make([]ent.Value, 0, len(m.flow_instances))
		for id := range m.flow_instances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FlowDeploymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedflow_instances != nil {
		edges = append(edges, flowdeployment.EdgeFlowInstances)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FlowDeploymentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case flowdeployment.EdgeFlowInstances:
		ids := make([]ent.Value, 0, len(m.removedflow_instances))
		for id := range m.removedflow_instances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FlowDeploymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedflow_definition {
		edges = append(edges, flowdeployment.EdgeFlowDefinition)
	}
	if m.clearedflow_instances {
		edges = append(edges, flowdeployment.EdgeFlowInstances)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FlowDeploymentMutation) EdgeCleared(name string) bool {
	switch name {
	case flowdeployment.EdgeFlowDefinition:
		return m.clearedflow_definition
	case flowdeployment.EdgeFlowInstances:
		return m.clearedflow_instances
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FlowDeploymentMutation) ClearEdge(name string) error {
	switch name {
	case flowdeployment.EdgeFlowDefinition:
		m.ClearFlowDefinition()
		return nil
	}
	return fmt.Errorf("unknown FlowDeployment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FlowDeploymentMutation) ResetEdge(name string) error {
	switch name {
	case flowdeployment.EdgeFlowDefinition:
		m.ResetFlowDefinition()
		return nil
	case flowdeployment.EdgeFlowInstances:
		m.ResetFlowInstances()
		return nil
	}
	return fmt.Errorf("unknown FlowDeployment edge %s", name)
}

// FlowInstanceMutation represents an operation that mutates the FlowInstance nodes in the graph.
type FlowInstanceMutation struct {
	config
	op                         Op
	typ                        string
	id                         *string
	created_at                 *int64
	addcreated_at              *int64
	updated_at                 *int64
	addupdated_at              *int64
	deleted_at                 *int64
	adddeleted_at              *int64
	ref_id                     *string
	status                     *int8
	addstatus                  *int8
	clearedFields              map[string]struct{}
	flow_deployment            *string
	clearedflow_deployment     bool
	flow_node_instances        map[string]struct{}
	removedflow_node_instances map[string]struct{}
	clearedflow_node_instances bool
	done                       bool
	oldValue                   func(context.Context) (*FlowInstance, error)
	predicates                 []predicate.FlowInstance
}

var _ ent.Mutation = (*FlowInstanceMutation)(nil)

// flowinstanceOption allows management of the mutation configuration using functional options.
type flowinstanceOption func(*FlowInstanceMutation)

// newFlowInstanceMutation creates new mutation for the FlowInstance entity.
func newFlowInstanceMutation(c config, op Op, opts ...flowinstanceOption) *FlowInstanceMutation {
	m := &FlowInstanceMutation{
		config:        c,
		op:            op,
		typ:           TypeFlowInstance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFlowInstanceID sets the ID field of the mutation.
func withFlowInstanceID(id string) flowinstanceOption {
	return func(m *FlowInstanceMutation) {
		var (
			err   error
			once  sync.Once
			value *FlowInstance
		)
		m.oldValue = func(ctx context.Context) (*FlowInstance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FlowInstance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFlowInstance sets the old FlowInstance of the mutation.
func withFlowInstance(node *FlowInstance) flowinstanceOption {
	return func(m *FlowInstanceMutation) {
		m.oldValue = func(context.Context) (*FlowInstance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FlowInstanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FlowInstanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FlowInstance entities.
func (m *FlowInstanceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FlowInstanceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FlowInstanceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FlowInstance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FlowInstanceMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FlowInstanceMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FlowInstance entity.
// If the FlowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowInstanceMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *FlowInstanceMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *FlowInstanceMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FlowInstanceMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FlowInstanceMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FlowInstanceMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FlowInstance entity.
// If the FlowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowInstanceMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *FlowInstanceMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *FlowInstanceMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FlowInstanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FlowInstanceMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FlowInstanceMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FlowInstance entity.
// If the FlowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowInstanceMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *FlowInstanceMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *FlowInstanceMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FlowInstanceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
	m.clearedFields[flowinstance.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FlowInstanceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[flowinstance.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FlowInstanceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
	delete(m.clearedFields, flowinstance.FieldDeletedAt)
}

// SetFlowDeploymentID sets the "flow_deployment_id" field.
func (m *FlowInstanceMutation) SetFlowDeploymentID(s string) {
	m.flow_deployment = &s
}

// FlowDeploymentID returns the value of the "flow_deployment_id" field in the mutation.
func (m *FlowInstanceMutation) FlowDeploymentID() (r string, exists bool) {
	v := m.flow_deployment
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowDeploymentID returns the old "flow_deployment_id" field's value of the FlowInstance entity.
// If the FlowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowInstanceMutation) OldFlowDeploymentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowDeploymentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowDeploymentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowDeploymentID: %w", err)
	}
	return oldValue.FlowDeploymentID, nil
}

// ResetFlowDeploymentID resets all changes to the "flow_deployment_id" field.
func (m *FlowInstanceMutation) ResetFlowDeploymentID() {
	m.flow_deployment = nil
}

// SetRefID sets the "ref_id" field.
func (m *FlowInstanceMutation) SetRefID(s string) {
	m.ref_id = &s
}

// RefID returns the value of the "ref_id" field in the mutation.
func (m *FlowInstanceMutation) RefID() (r string, exists bool) {
	v := m.ref_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRefID returns the old "ref_id" field's value of the FlowInstance entity.
// If the FlowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowInstanceMutation) OldRefID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefID: %w", err)
	}
	return oldValue.RefID, nil
}

// ResetRefID resets all changes to the "ref_id" field.
func (m *FlowInstanceMutation) ResetRefID() {
	m.ref_id = nil
}

// SetStatus sets the "status" field.
func (m *FlowInstanceMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *FlowInstanceMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the FlowInstance entity.
// If the FlowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowInstanceMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *FlowInstanceMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *FlowInstanceMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *FlowInstanceMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// ClearFlowDeployment clears the "flow_deployment" edge to the FlowDeployment entity.
func (m *FlowInstanceMutation) ClearFlowDeployment() {
	m.clearedflow_deployment = true
}

// FlowDeploymentCleared reports if the "flow_deployment" edge to the FlowDeployment entity was cleared.
func (m *FlowInstanceMutation) FlowDeploymentCleared() bool {
	return m.clearedflow_deployment
}

// FlowDeploymentIDs returns the "flow_deployment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FlowDeploymentID instead. It exists only for internal usage by the builders.
func (m *FlowInstanceMutation) FlowDeploymentIDs() (ids []string) {
	if id := m.flow_deployment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFlowDeployment resets all changes to the "flow_deployment" edge.
func (m *FlowInstanceMutation) ResetFlowDeployment() {
	m.flow_deployment = nil
	m.clearedflow_deployment = false
}

// AddFlowNodeInstanceIDs adds the "flow_node_instances" edge to the FlowNodeInstance entity by ids.
func (m *FlowInstanceMutation) AddFlowNodeInstanceIDs(ids ...string) {
	if m.flow_node_instances == nil {
		m.flow_node_instances = make(map[string]struct{})
	}
	for i := range ids {
		m.flow_node_instances[ids[i]] = struct{}{}
	}
}

// ClearFlowNodeInstances clears the "flow_node_instances" edge to the FlowNodeInstance entity.
func (m *FlowInstanceMutation) ClearFlowNodeInstances() {
	m.clearedflow_node_instances = true
}

// FlowNodeInstancesCleared reports if the "flow_node_instances" edge to the FlowNodeInstance entity was cleared.
func (m *FlowInstanceMutation) FlowNodeInstancesCleared() bool {
	return m.clearedflow_node_instances
}

// RemoveFlowNodeInstanceIDs removes the "flow_node_instances" edge to the FlowNodeInstance entity by IDs.
func (m *FlowInstanceMutation) RemoveFlowNodeInstanceIDs(ids ...string) {
	if m.removedflow_node_instances == nil {
		m.removedflow_node_instances = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.flow_node_instances, ids[i])
		m.removedflow_node_instances[ids[i]] = struct{}{}
	}
}

// RemovedFlowNodeInstances returns the removed IDs of the "flow_node_instances" edge to the FlowNodeInstance entity.
func (m *FlowInstanceMutation) RemovedFlowNodeInstancesIDs() (ids []string) {
	for id := range m.removedflow_node_instances {
		ids = append(ids, id)
	}
	return
}

// FlowNodeInstancesIDs returns the "flow_node_instances" edge IDs in the mutation.
func (m *FlowInstanceMutation) FlowNodeInstancesIDs() (ids []string) {
	for id := range m.flow_node_instances {
		ids = append(ids, id)
	}
	return
}

// ResetFlowNodeInstances resets all changes to the "flow_node_instances" edge.
func (m *FlowInstanceMutation) ResetFlowNodeInstances() {
	m.flow_node_instances = nil
	m.clearedflow_node_instances = false
	m.removedflow_node_instances = nil
}

// Where appends a list predicates to the FlowInstanceMutation builder.
func (m *FlowInstanceMutation) Where(ps ...predicate.FlowInstance) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FlowInstanceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FlowInstance).
func (m *FlowInstanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FlowInstanceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, flowinstance.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, flowinstance.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, flowinstance.FieldDeletedAt)
	}
	if m.flow_deployment != nil {
		fields = append(fields, flowinstance.FieldFlowDeploymentID)
	}
	if m.ref_id != nil {
		fields = append(fields, flowinstance.FieldRefID)
	}
	if m.status != nil {
		fields = append(fields, flowinstance.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FlowInstanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flowinstance.FieldCreatedAt:
		return m.CreatedAt()
	case flowinstance.FieldUpdatedAt:
		return m.UpdatedAt()
	case flowinstance.FieldDeletedAt:
		return m.DeletedAt()
	case flowinstance.FieldFlowDeploymentID:
		return m.FlowDeploymentID()
	case flowinstance.FieldRefID:
		return m.RefID()
	case flowinstance.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FlowInstanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flowinstance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case flowinstance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case flowinstance.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case flowinstance.FieldFlowDeploymentID:
		return m.OldFlowDeploymentID(ctx)
	case flowinstance.FieldRefID:
		return m.OldRefID(ctx)
	case flowinstance.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown FlowInstance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlowInstanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flowinstance.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case flowinstance.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case flowinstance.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case flowinstance.FieldFlowDeploymentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowDeploymentID(v)
		return nil
	case flowinstance.FieldRefID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefID(v)
		return nil
	case flowinstance.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown FlowInstance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FlowInstanceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, flowinstance.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, flowinstance.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, flowinstance.FieldDeletedAt)
	}
	if m.addstatus != nil {
		fields = append(fields, flowinstance.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FlowInstanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case flowinstance.FieldCreatedAt:
		return m.AddedCreatedAt()
	case flowinstance.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case flowinstance.FieldDeletedAt:
		return m.AddedDeletedAt()
	case flowinstance.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlowInstanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case flowinstance.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case flowinstance.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case flowinstance.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case flowinstance.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown FlowInstance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FlowInstanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(flowinstance.FieldDeletedAt) {
		fields = append(fields, flowinstance.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FlowInstanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FlowInstanceMutation) ClearField(name string) error {
	switch name {
	case flowinstance.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown FlowInstance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FlowInstanceMutation) ResetField(name string) error {
	switch name {
	case flowinstance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case flowinstance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case flowinstance.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case flowinstance.FieldFlowDeploymentID:
		m.ResetFlowDeploymentID()
		return nil
	case flowinstance.FieldRefID:
		m.ResetRefID()
		return nil
	case flowinstance.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown FlowInstance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FlowInstanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.flow_deployment != nil {
		edges = append(edges, flowinstance.EdgeFlowDeployment)
	}
	if m.flow_node_instances != nil {
		edges = append(edges, flowinstance.EdgeFlowNodeInstances)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FlowInstanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case flowinstance.EdgeFlowDeployment:
		if id := m.flow_deployment; id != nil {
			return []ent.Value{*id}
		}
	case flowinstance.EdgeFlowNodeInstances:
		ids := make([]ent.Value, 0, len(m.flow_node_instances))
		for id := range m.flow_node_instances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FlowInstanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedflow_node_instances != nil {
		edges = append(edges, flowinstance.EdgeFlowNodeInstances)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FlowInstanceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case flowinstance.EdgeFlowNodeInstances:
		ids := make([]ent.Value, 0, len(m.removedflow_node_instances))
		for id := range m.removedflow_node_instances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FlowInstanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedflow_deployment {
		edges = append(edges, flowinstance.EdgeFlowDeployment)
	}
	if m.clearedflow_node_instances {
		edges = append(edges, flowinstance.EdgeFlowNodeInstances)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FlowInstanceMutation) EdgeCleared(name string) bool {
	switch name {
	case flowinstance.EdgeFlowDeployment:
		return m.clearedflow_deployment
	case flowinstance.EdgeFlowNodeInstances:
		return m.clearedflow_node_instances
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FlowInstanceMutation) ClearEdge(name string) error {
	switch name {
	case flowinstance.EdgeFlowDeployment:
		m.ClearFlowDeployment()
		return nil
	}
	return fmt.Errorf("unknown FlowInstance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FlowInstanceMutation) ResetEdge(name string) error {
	switch name {
	case flowinstance.EdgeFlowDeployment:
		m.ResetFlowDeployment()
		return nil
	case flowinstance.EdgeFlowNodeInstances:
		m.ResetFlowNodeInstances()
		return nil
	}
	return fmt.Errorf("unknown FlowInstance edge %s", name)
}

// FlowInstanceDataMutation represents an operation that mutates the FlowInstanceData nodes in the graph.
type FlowInstanceDataMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	created_at            *int64
	addcreated_at         *int64
	updated_at            *int64
	addupdated_at         *int64
	deleted_at            *int64
	adddeleted_at         *int64
	flow_instance_id      *string
	flow_node_instance_id *string
	node_key              *string
	data                  *map[string]interface{}
	_type                 *int8
	add_type              *int8
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*FlowInstanceData, error)
	predicates            []predicate.FlowInstanceData
}

var _ ent.Mutation = (*FlowInstanceDataMutation)(nil)

// flowinstancedataOption allows management of the mutation configuration using functional options.
type flowinstancedataOption func(*FlowInstanceDataMutation)

// newFlowInstanceDataMutation creates new mutation for the FlowInstanceData entity.
func newFlowInstanceDataMutation(c config, op Op, opts ...flowinstancedataOption) *FlowInstanceDataMutation {
	m := &FlowInstanceDataMutation{
		config:        c,
		op:            op,
		typ:           TypeFlowInstanceData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFlowInstanceDataID sets the ID field of the mutation.
func withFlowInstanceDataID(id string) flowinstancedataOption {
	return func(m *FlowInstanceDataMutation) {
		var (
			err   error
			once  sync.Once
			value *FlowInstanceData
		)
		m.oldValue = func(ctx context.Context) (*FlowInstanceData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FlowInstanceData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFlowInstanceData sets the old FlowInstanceData of the mutation.
func withFlowInstanceData(node *FlowInstanceData) flowinstancedataOption {
	return func(m *FlowInstanceDataMutation) {
		m.oldValue = func(context.Context) (*FlowInstanceData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FlowInstanceDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FlowInstanceDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FlowInstanceData entities.
func (m *FlowInstanceDataMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FlowInstanceDataMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FlowInstanceDataMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FlowInstanceData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FlowInstanceDataMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FlowInstanceDataMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FlowInstanceData entity.
// If the FlowInstanceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowInstanceDataMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *FlowInstanceDataMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *FlowInstanceDataMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FlowInstanceDataMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FlowInstanceDataMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FlowInstanceDataMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FlowInstanceData entity.
// If the FlowInstanceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowInstanceDataMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *FlowInstanceDataMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *FlowInstanceDataMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FlowInstanceDataMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FlowInstanceDataMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FlowInstanceDataMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FlowInstanceData entity.
// If the FlowInstanceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowInstanceDataMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *FlowInstanceDataMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *FlowInstanceDataMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FlowInstanceDataMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
	m.clearedFields[flowinstancedata.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FlowInstanceDataMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[flowinstancedata.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FlowInstanceDataMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
	delete(m.clearedFields, flowinstancedata.FieldDeletedAt)
}

// SetFlowInstanceID sets the "flow_instance_id" field.
func (m *FlowInstanceDataMutation) SetFlowInstanceID(s string) {
	m.flow_instance_id = &s
}

// FlowInstanceID returns the value of the "flow_instance_id" field in the mutation.
func (m *FlowInstanceDataMutation) FlowInstanceID() (r string, exists bool) {
	v := m.flow_instance_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowInstanceID returns the old "flow_instance_id" field's value of the FlowInstanceData entity.
// If the FlowInstanceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowInstanceDataMutation) OldFlowInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowInstanceID: %w", err)
	}
	return oldValue.FlowInstanceID, nil
}

// ResetFlowInstanceID resets all changes to the "flow_instance_id" field.
func (m *FlowInstanceDataMutation) ResetFlowInstanceID() {
	m.flow_instance_id = nil
}

// SetFlowNodeInstanceID sets the "flow_node_instance_id" field.
func (m *FlowInstanceDataMutation) SetFlowNodeInstanceID(s string) {
	m.flow_node_instance_id = &s
}

// FlowNodeInstanceID returns the value of the "flow_node_instance_id" field in the mutation.
func (m *FlowInstanceDataMutation) FlowNodeInstanceID() (r string, exists bool) {
	v := m.flow_node_instance_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowNodeInstanceID returns the old "flow_node_instance_id" field's value of the FlowInstanceData entity.
// If the FlowInstanceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowInstanceDataMutation) OldFlowNodeInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowNodeInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowNodeInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowNodeInstanceID: %w", err)
	}
	return oldValue.FlowNodeInstanceID, nil
}

// ClearFlowNodeInstanceID clears the value of the "flow_node_instance_id" field.
func (m *FlowInstanceDataMutation) ClearFlowNodeInstanceID() {
	m.flow_node_instance_id = nil
	m.clearedFields[flowinstancedata.FieldFlowNodeInstanceID] = struct{}{}
}

// FlowNodeInstanceIDCleared returns if the "flow_node_instance_id" field was cleared in this mutation.
func (m *FlowInstanceDataMutation) FlowNodeInstanceIDCleared() bool {
	_, ok := m.clearedFields[flowinstancedata.FieldFlowNodeInstanceID]
	return ok
}

// ResetFlowNodeInstanceID resets all changes to the "flow_node_instance_id" field.
func (m *FlowInstanceDataMutation) ResetFlowNodeInstanceID() {
	m.flow_node_instance_id = nil
	delete(m.clearedFields, flowinstancedata.FieldFlowNodeInstanceID)
}

// SetNodeKey sets the "node_key" field.
func (m *FlowInstanceDataMutation) SetNodeKey(s string) {
	m.node_key = &s
}

// NodeKey returns the value of the "node_key" field in the mutation.
func (m *FlowInstanceDataMutation) NodeKey() (r string, exists bool) {
	v := m.node_key
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeKey returns the old "node_key" field's value of the FlowInstanceData entity.
// If the FlowInstanceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowInstanceDataMutation) OldNodeKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeKey: %w", err)
	}
	return oldValue.NodeKey, nil
}

// ClearNodeKey clears the value of the "node_key" field.
func (m *FlowInstanceDataMutation) ClearNodeKey() {
	m.node_key = nil
	m.clearedFields[flowinstancedata.FieldNodeKey] = struct{}{}
}

// NodeKeyCleared returns if the "node_key" field was cleared in this mutation.
func (m *FlowInstanceDataMutation) NodeKeyCleared() bool {
	_, ok := m.clearedFields[flowinstancedata.FieldNodeKey]
	return ok
}

// ResetNodeKey resets all changes to the "node_key" field.
func (m *FlowInstanceDataMutation) ResetNodeKey() {
	m.node_key = nil
	delete(m.clearedFields, flowinstancedata.FieldNodeKey)
}

// SetData sets the "data" field.
func (m *FlowInstanceDataMutation) SetData(value map[string]interface{}) {
	m.data = &value
}

// Data returns the value of the "data" field in the mutation.
func (m *FlowInstanceDataMutation) Data() (r map[string]interface{}, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the FlowInstanceData entity.
// If the FlowInstanceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowInstanceDataMutation) OldData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ClearData clears the value of the "data" field.
func (m *FlowInstanceDataMutation) ClearData() {
	m.data = nil
	m.clearedFields[flowinstancedata.FieldData] = struct{}{}
}

// DataCleared returns if the "data" field was cleared in this mutation.
func (m *FlowInstanceDataMutation) DataCleared() bool {
	_, ok := m.clearedFields[flowinstancedata.FieldData]
	return ok
}

// ResetData resets all changes to the "data" field.
func (m *FlowInstanceDataMutation) ResetData() {
	m.data = nil
	delete(m.clearedFields, flowinstancedata.FieldData)
}

// SetType sets the "type" field.
func (m *FlowInstanceDataMutation) SetType(i int8) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *FlowInstanceDataMutation) GetType() (r int8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the FlowInstanceData entity.
// If the FlowInstanceData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowInstanceDataMutation) OldType(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *FlowInstanceDataMutation) AddType(i int8) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *FlowInstanceDataMutation) AddedType() (r int8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *FlowInstanceDataMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// Where appends a list predicates to the FlowInstanceDataMutation builder.
func (m *FlowInstanceDataMutation) Where(ps ...predicate.FlowInstanceData) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FlowInstanceDataMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FlowInstanceData).
func (m *FlowInstanceDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FlowInstanceDataMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, flowinstancedata.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, flowinstancedata.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, flowinstancedata.FieldDeletedAt)
	}
	if m.flow_instance_id != nil {
		fields = append(fields, flowinstancedata.FieldFlowInstanceID)
	}
	if m.flow_node_instance_id != nil {
		fields = append(fields, flowinstancedata.FieldFlowNodeInstanceID)
	}
	if m.node_key != nil {
		fields = append(fields, flowinstancedata.FieldNodeKey)
	}
	if m.data != nil {
		fields = append(fields, flowinstancedata.FieldData)
	}
	if m._type != nil {
		fields = append(fields, flowinstancedata.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FlowInstanceDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flowinstancedata.FieldCreatedAt:
		return m.CreatedAt()
	case flowinstancedata.FieldUpdatedAt:
		return m.UpdatedAt()
	case flowinstancedata.FieldDeletedAt:
		return m.DeletedAt()
	case flowinstancedata.FieldFlowInstanceID:
		return m.FlowInstanceID()
	case flowinstancedata.FieldFlowNodeInstanceID:
		return m.FlowNodeInstanceID()
	case flowinstancedata.FieldNodeKey:
		return m.NodeKey()
	case flowinstancedata.FieldData:
		return m.Data()
	case flowinstancedata.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FlowInstanceDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flowinstancedata.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case flowinstancedata.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case flowinstancedata.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case flowinstancedata.FieldFlowInstanceID:
		return m.OldFlowInstanceID(ctx)
	case flowinstancedata.FieldFlowNodeInstanceID:
		return m.OldFlowNodeInstanceID(ctx)
	case flowinstancedata.FieldNodeKey:
		return m.OldNodeKey(ctx)
	case flowinstancedata.FieldData:
		return m.OldData(ctx)
	case flowinstancedata.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown FlowInstanceData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlowInstanceDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flowinstancedata.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case flowinstancedata.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case flowinstancedata.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case flowinstancedata.FieldFlowInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowInstanceID(v)
		return nil
	case flowinstancedata.FieldFlowNodeInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowNodeInstanceID(v)
		return nil
	case flowinstancedata.FieldNodeKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeKey(v)
		return nil
	case flowinstancedata.FieldData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case flowinstancedata.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown FlowInstanceData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FlowInstanceDataMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, flowinstancedata.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, flowinstancedata.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, flowinstancedata.FieldDeletedAt)
	}
	if m.add_type != nil {
		fields = append(fields, flowinstancedata.FieldType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FlowInstanceDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case flowinstancedata.FieldCreatedAt:
		return m.AddedCreatedAt()
	case flowinstancedata.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case flowinstancedata.FieldDeletedAt:
		return m.AddedDeletedAt()
	case flowinstancedata.FieldType:
		return m.AddedType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlowInstanceDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case flowinstancedata.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case flowinstancedata.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case flowinstancedata.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case flowinstancedata.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	}
	return fmt.Errorf("unknown FlowInstanceData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FlowInstanceDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(flowinstancedata.FieldDeletedAt) {
		fields = append(fields, flowinstancedata.FieldDeletedAt)
	}
	if m.FieldCleared(flowinstancedata.FieldFlowNodeInstanceID) {
		fields = append(fields, flowinstancedata.FieldFlowNodeInstanceID)
	}
	if m.FieldCleared(flowinstancedata.FieldNodeKey) {
		fields = append(fields, flowinstancedata.FieldNodeKey)
	}
	if m.FieldCleared(flowinstancedata.FieldData) {
		fields = append(fields, flowinstancedata.FieldData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FlowInstanceDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FlowInstanceDataMutation) ClearField(name string) error {
	switch name {
	case flowinstancedata.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case flowinstancedata.FieldFlowNodeInstanceID:
		m.ClearFlowNodeInstanceID()
		return nil
	case flowinstancedata.FieldNodeKey:
		m.ClearNodeKey()
		return nil
	case flowinstancedata.FieldData:
		m.ClearData()
		return nil
	}
	return fmt.Errorf("unknown FlowInstanceData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FlowInstanceDataMutation) ResetField(name string) error {
	switch name {
	case flowinstancedata.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case flowinstancedata.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case flowinstancedata.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case flowinstancedata.FieldFlowInstanceID:
		m.ResetFlowInstanceID()
		return nil
	case flowinstancedata.FieldFlowNodeInstanceID:
		m.ResetFlowNodeInstanceID()
		return nil
	case flowinstancedata.FieldNodeKey:
		m.ResetNodeKey()
		return nil
	case flowinstancedata.FieldData:
		m.ResetData()
		return nil
	case flowinstancedata.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown FlowInstanceData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FlowInstanceDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FlowInstanceDataMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FlowInstanceDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FlowInstanceDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FlowInstanceDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FlowInstanceDataMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FlowInstanceDataMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FlowInstanceData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FlowInstanceDataMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FlowInstanceData edge %s", name)
}

// FlowNodeInstanceMutation represents an operation that mutates the FlowNodeInstance nodes in the graph.
type FlowNodeInstanceMutation struct {
	config
	op                           Op
	typ                          string
	id                           *string
	created_at                   *int64
	addcreated_at                *int64
	updated_at                   *int64
	addupdated_at                *int64
	deleted_at                   *int64
	adddeleted_at                *int64
	source_flow_node_instance_id *string
	flow_instance_data_id        *string
	node_key                     *string
	source_node_key              *string
	status                       *int8
	addstatus                    *int8
	clearedFields                map[string]struct{}
	flow_instance                *string
	clearedflow_instance         bool
	done                         bool
	oldValue                     func(context.Context) (*FlowNodeInstance, error)
	predicates                   []predicate.FlowNodeInstance
}

var _ ent.Mutation = (*FlowNodeInstanceMutation)(nil)

// flownodeinstanceOption allows management of the mutation configuration using functional options.
type flownodeinstanceOption func(*FlowNodeInstanceMutation)

// newFlowNodeInstanceMutation creates new mutation for the FlowNodeInstance entity.
func newFlowNodeInstanceMutation(c config, op Op, opts ...flownodeinstanceOption) *FlowNodeInstanceMutation {
	m := &FlowNodeInstanceMutation{
		config:        c,
		op:            op,
		typ:           TypeFlowNodeInstance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFlowNodeInstanceID sets the ID field of the mutation.
func withFlowNodeInstanceID(id string) flownodeinstanceOption {
	return func(m *FlowNodeInstanceMutation) {
		var (
			err   error
			once  sync.Once
			value *FlowNodeInstance
		)
		m.oldValue = func(ctx context.Context) (*FlowNodeInstance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FlowNodeInstance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFlowNodeInstance sets the old FlowNodeInstance of the mutation.
func withFlowNodeInstance(node *FlowNodeInstance) flownodeinstanceOption {
	return func(m *FlowNodeInstanceMutation) {
		m.oldValue = func(context.Context) (*FlowNodeInstance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FlowNodeInstanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FlowNodeInstanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FlowNodeInstance entities.
func (m *FlowNodeInstanceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FlowNodeInstanceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FlowNodeInstanceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FlowNodeInstance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FlowNodeInstanceMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FlowNodeInstanceMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FlowNodeInstance entity.
// If the FlowNodeInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowNodeInstanceMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *FlowNodeInstanceMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *FlowNodeInstanceMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FlowNodeInstanceMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FlowNodeInstanceMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FlowNodeInstanceMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FlowNodeInstance entity.
// If the FlowNodeInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowNodeInstanceMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *FlowNodeInstanceMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *FlowNodeInstanceMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FlowNodeInstanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FlowNodeInstanceMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FlowNodeInstanceMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FlowNodeInstance entity.
// If the FlowNodeInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowNodeInstanceMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *FlowNodeInstanceMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *FlowNodeInstanceMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FlowNodeInstanceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
	m.clearedFields[flownodeinstance.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FlowNodeInstanceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[flownodeinstance.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FlowNodeInstanceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
	delete(m.clearedFields, flownodeinstance.FieldDeletedAt)
}

// SetFlowInstanceID sets the "flow_instance_id" field.
func (m *FlowNodeInstanceMutation) SetFlowInstanceID(s string) {
	m.flow_instance = &s
}

// FlowInstanceID returns the value of the "flow_instance_id" field in the mutation.
func (m *FlowNodeInstanceMutation) FlowInstanceID() (r string, exists bool) {
	v := m.flow_instance
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowInstanceID returns the old "flow_instance_id" field's value of the FlowNodeInstance entity.
// If the FlowNodeInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowNodeInstanceMutation) OldFlowInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowInstanceID: %w", err)
	}
	return oldValue.FlowInstanceID, nil
}

// ResetFlowInstanceID resets all changes to the "flow_instance_id" field.
func (m *FlowNodeInstanceMutation) ResetFlowInstanceID() {
	m.flow_instance = nil
}

// SetSourceFlowNodeInstanceID sets the "source_flow_node_instance_id" field.
func (m *FlowNodeInstanceMutation) SetSourceFlowNodeInstanceID(s string) {
	m.source_flow_node_instance_id = &s
}

// SourceFlowNodeInstanceID returns the value of the "source_flow_node_instance_id" field in the mutation.
func (m *FlowNodeInstanceMutation) SourceFlowNodeInstanceID() (r string, exists bool) {
	v := m.source_flow_node_instance_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceFlowNodeInstanceID returns the old "source_flow_node_instance_id" field's value of the FlowNodeInstance entity.
// If the FlowNodeInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowNodeInstanceMutation) OldSourceFlowNodeInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceFlowNodeInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceFlowNodeInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceFlowNodeInstanceID: %w", err)
	}
	return oldValue.SourceFlowNodeInstanceID, nil
}

// ClearSourceFlowNodeInstanceID clears the value of the "source_flow_node_instance_id" field.
func (m *FlowNodeInstanceMutation) ClearSourceFlowNodeInstanceID() {
	m.source_flow_node_instance_id = nil
	m.clearedFields[flownodeinstance.FieldSourceFlowNodeInstanceID] = struct{}{}
}

// SourceFlowNodeInstanceIDCleared returns if the "source_flow_node_instance_id" field was cleared in this mutation.
func (m *FlowNodeInstanceMutation) SourceFlowNodeInstanceIDCleared() bool {
	_, ok := m.clearedFields[flownodeinstance.FieldSourceFlowNodeInstanceID]
	return ok
}

// ResetSourceFlowNodeInstanceID resets all changes to the "source_flow_node_instance_id" field.
func (m *FlowNodeInstanceMutation) ResetSourceFlowNodeInstanceID() {
	m.source_flow_node_instance_id = nil
	delete(m.clearedFields, flownodeinstance.FieldSourceFlowNodeInstanceID)
}

// SetFlowInstanceDataID sets the "flow_instance_data_id" field.
func (m *FlowNodeInstanceMutation) SetFlowInstanceDataID(s string) {
	m.flow_instance_data_id = &s
}

// FlowInstanceDataID returns the value of the "flow_instance_data_id" field in the mutation.
func (m *FlowNodeInstanceMutation) FlowInstanceDataID() (r string, exists bool) {
	v := m.flow_instance_data_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowInstanceDataID returns the old "flow_instance_data_id" field's value of the FlowNodeInstance entity.
// If the FlowNodeInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowNodeInstanceMutation) OldFlowInstanceDataID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowInstanceDataID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowInstanceDataID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowInstanceDataID: %w", err)
	}
	return oldValue.FlowInstanceDataID, nil
}

// ClearFlowInstanceDataID clears the value of the "flow_instance_data_id" field.
func (m *FlowNodeInstanceMutation) ClearFlowInstanceDataID() {
	m.flow_instance_data_id = nil
	m.clearedFields[flownodeinstance.FieldFlowInstanceDataID] = struct{}{}
}

// FlowInstanceDataIDCleared returns if the "flow_instance_data_id" field was cleared in this mutation.
func (m *FlowNodeInstanceMutation) FlowInstanceDataIDCleared() bool {
	_, ok := m.clearedFields[flownodeinstance.FieldFlowInstanceDataID]
	return ok
}

// ResetFlowInstanceDataID resets all changes to the "flow_instance_data_id" field.
func (m *FlowNodeInstanceMutation) ResetFlowInstanceDataID() {
	m.flow_instance_data_id = nil
	delete(m.clearedFields, flownodeinstance.FieldFlowInstanceDataID)
}

// SetNodeKey sets the "node_key" field.
func (m *FlowNodeInstanceMutation) SetNodeKey(s string) {
	m.node_key = &s
}

// NodeKey returns the value of the "node_key" field in the mutation.
func (m *FlowNodeInstanceMutation) NodeKey() (r string, exists bool) {
	v := m.node_key
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeKey returns the old "node_key" field's value of the FlowNodeInstance entity.
// If the FlowNodeInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowNodeInstanceMutation) OldNodeKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeKey: %w", err)
	}
	return oldValue.NodeKey, nil
}

// ResetNodeKey resets all changes to the "node_key" field.
func (m *FlowNodeInstanceMutation) ResetNodeKey() {
	m.node_key = nil
}

// SetSourceNodeKey sets the "source_node_key" field.
func (m *FlowNodeInstanceMutation) SetSourceNodeKey(s string) {
	m.source_node_key = &s
}

// SourceNodeKey returns the value of the "source_node_key" field in the mutation.
func (m *FlowNodeInstanceMutation) SourceNodeKey() (r string, exists bool) {
	v := m.source_node_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceNodeKey returns the old "source_node_key" field's value of the FlowNodeInstance entity.
// If the FlowNodeInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowNodeInstanceMutation) OldSourceNodeKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceNodeKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceNodeKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceNodeKey: %w", err)
	}
	return oldValue.SourceNodeKey, nil
}

// ClearSourceNodeKey clears the value of the "source_node_key" field.
func (m *FlowNodeInstanceMutation) ClearSourceNodeKey() {
	m.source_node_key = nil
	m.clearedFields[flownodeinstance.FieldSourceNodeKey] = struct{}{}
}

// SourceNodeKeyCleared returns if the "source_node_key" field was cleared in this mutation.
func (m *FlowNodeInstanceMutation) SourceNodeKeyCleared() bool {
	_, ok := m.clearedFields[flownodeinstance.FieldSourceNodeKey]
	return ok
}

// ResetSourceNodeKey resets all changes to the "source_node_key" field.
func (m *FlowNodeInstanceMutation) ResetSourceNodeKey() {
	m.source_node_key = nil
	delete(m.clearedFields, flownodeinstance.FieldSourceNodeKey)
}

// SetStatus sets the "status" field.
func (m *FlowNodeInstanceMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *FlowNodeInstanceMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the FlowNodeInstance entity.
// If the FlowNodeInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowNodeInstanceMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *FlowNodeInstanceMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *FlowNodeInstanceMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *FlowNodeInstanceMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// ClearFlowInstance clears the "flow_instance" edge to the FlowInstance entity.
func (m *FlowNodeInstanceMutation) ClearFlowInstance() {
	m.clearedflow_instance = true
}

// FlowInstanceCleared reports if the "flow_instance" edge to the FlowInstance entity was cleared.
func (m *FlowNodeInstanceMutation) FlowInstanceCleared() bool {
	return m.clearedflow_instance
}

// FlowInstanceIDs returns the "flow_instance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FlowInstanceID instead. It exists only for internal usage by the builders.
func (m *FlowNodeInstanceMutation) FlowInstanceIDs() (ids []string) {
	if id := m.flow_instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFlowInstance resets all changes to the "flow_instance" edge.
func (m *FlowNodeInstanceMutation) ResetFlowInstance() {
	m.flow_instance = nil
	m.clearedflow_instance = false
}

// Where appends a list predicates to the FlowNodeInstanceMutation builder.
func (m *FlowNodeInstanceMutation) Where(ps ...predicate.FlowNodeInstance) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FlowNodeInstanceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FlowNodeInstance).
func (m *FlowNodeInstanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FlowNodeInstanceMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, flownodeinstance.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, flownodeinstance.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, flownodeinstance.FieldDeletedAt)
	}
	if m.flow_instance != nil {
		fields = append(fields, flownodeinstance.FieldFlowInstanceID)
	}
	if m.source_flow_node_instance_id != nil {
		fields = append(fields, flownodeinstance.FieldSourceFlowNodeInstanceID)
	}
	if m.flow_instance_data_id != nil {
		fields = append(fields, flownodeinstance.FieldFlowInstanceDataID)
	}
	if m.node_key != nil {
		fields = append(fields, flownodeinstance.FieldNodeKey)
	}
	if m.source_node_key != nil {
		fields = append(fields, flownodeinstance.FieldSourceNodeKey)
	}
	if m.status != nil {
		fields = append(fields, flownodeinstance.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FlowNodeInstanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flownodeinstance.FieldCreatedAt:
		return m.CreatedAt()
	case flownodeinstance.FieldUpdatedAt:
		return m.UpdatedAt()
	case flownodeinstance.FieldDeletedAt:
		return m.DeletedAt()
	case flownodeinstance.FieldFlowInstanceID:
		return m.FlowInstanceID()
	case flownodeinstance.FieldSourceFlowNodeInstanceID:
		return m.SourceFlowNodeInstanceID()
	case flownodeinstance.FieldFlowInstanceDataID:
		return m.FlowInstanceDataID()
	case flownodeinstance.FieldNodeKey:
		return m.NodeKey()
	case flownodeinstance.FieldSourceNodeKey:
		return m.SourceNodeKey()
	case flownodeinstance.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FlowNodeInstanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flownodeinstance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case flownodeinstance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case flownodeinstance.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case flownodeinstance.FieldFlowInstanceID:
		return m.OldFlowInstanceID(ctx)
	case flownodeinstance.FieldSourceFlowNodeInstanceID:
		return m.OldSourceFlowNodeInstanceID(ctx)
	case flownodeinstance.FieldFlowInstanceDataID:
		return m.OldFlowInstanceDataID(ctx)
	case flownodeinstance.FieldNodeKey:
		return m.OldNodeKey(ctx)
	case flownodeinstance.FieldSourceNodeKey:
		return m.OldSourceNodeKey(ctx)
	case flownodeinstance.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown FlowNodeInstance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlowNodeInstanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flownodeinstance.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case flownodeinstance.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case flownodeinstance.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case flownodeinstance.FieldFlowInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowInstanceID(v)
		return nil
	case flownodeinstance.FieldSourceFlowNodeInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceFlowNodeInstanceID(v)
		return nil
	case flownodeinstance.FieldFlowInstanceDataID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowInstanceDataID(v)
		return nil
	case flownodeinstance.FieldNodeKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeKey(v)
		return nil
	case flownodeinstance.FieldSourceNodeKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceNodeKey(v)
		return nil
	case flownodeinstance.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown FlowNodeInstance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FlowNodeInstanceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, flownodeinstance.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, flownodeinstance.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, flownodeinstance.FieldDeletedAt)
	}
	if m.addstatus != nil {
		fields = append(fields, flownodeinstance.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FlowNodeInstanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case flownodeinstance.FieldCreatedAt:
		return m.AddedCreatedAt()
	case flownodeinstance.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case flownodeinstance.FieldDeletedAt:
		return m.AddedDeletedAt()
	case flownodeinstance.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlowNodeInstanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case flownodeinstance.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case flownodeinstance.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case flownodeinstance.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case flownodeinstance.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown FlowNodeInstance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FlowNodeInstanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(flownodeinstance.FieldDeletedAt) {
		fields = append(fields, flownodeinstance.FieldDeletedAt)
	}
	if m.FieldCleared(flownodeinstance.FieldSourceFlowNodeInstanceID) {
		fields = append(fields, flownodeinstance.FieldSourceFlowNodeInstanceID)
	}
	if m.FieldCleared(flownodeinstance.FieldFlowInstanceDataID) {
		fields = append(fields, flownodeinstance.FieldFlowInstanceDataID)
	}
	if m.FieldCleared(flownodeinstance.FieldSourceNodeKey) {
		fields = append(fields, flownodeinstance.FieldSourceNodeKey)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FlowNodeInstanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FlowNodeInstanceMutation) ClearField(name string) error {
	switch name {
	case flownodeinstance.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case flownodeinstance.FieldSourceFlowNodeInstanceID:
		m.ClearSourceFlowNodeInstanceID()
		return nil
	case flownodeinstance.FieldFlowInstanceDataID:
		m.ClearFlowInstanceDataID()
		return nil
	case flownodeinstance.FieldSourceNodeKey:
		m.ClearSourceNodeKey()
		return nil
	}
	return fmt.Errorf("unknown FlowNodeInstance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FlowNodeInstanceMutation) ResetField(name string) error {
	switch name {
	case flownodeinstance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case flownodeinstance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case flownodeinstance.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case flownodeinstance.FieldFlowInstanceID:
		m.ResetFlowInstanceID()
		return nil
	case flownodeinstance.FieldSourceFlowNodeInstanceID:
		m.ResetSourceFlowNodeInstanceID()
		return nil
	case flownodeinstance.FieldFlowInstanceDataID:
		m.ResetFlowInstanceDataID()
		return nil
	case flownodeinstance.FieldNodeKey:
		m.ResetNodeKey()
		return nil
	case flownodeinstance.FieldSourceNodeKey:
		m.ResetSourceNodeKey()
		return nil
	case flownodeinstance.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown FlowNodeInstance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FlowNodeInstanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.flow_instance != nil {
		edges = append(edges, flownodeinstance.EdgeFlowInstance)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FlowNodeInstanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case flownodeinstance.EdgeFlowInstance:
		if id := m.flow_instance; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FlowNodeInstanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FlowNodeInstanceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FlowNodeInstanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedflow_instance {
		edges = append(edges, flownodeinstance.EdgeFlowInstance)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FlowNodeInstanceMutation) EdgeCleared(name string) bool {
	switch name {
	case flownodeinstance.EdgeFlowInstance:
		return m.clearedflow_instance
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FlowNodeInstanceMutation) ClearEdge(name string) error {
	switch name {
	case flownodeinstance.EdgeFlowInstance:
		m.ClearFlowInstance()
		return nil
	}
	return fmt.Errorf("unknown FlowNodeInstance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FlowNodeInstanceMutation) ResetEdge(name string) error {
	switch name {
	case flownodeinstance.EdgeFlowInstance:
		m.ResetFlowInstance()
		return nil
	}
	return fmt.Errorf("unknown FlowNodeInstance edge %s", name)
}

// FlowNodeInstanceLogMutation represents an operation that mutates the FlowNodeInstanceLog nodes in the graph.
type FlowNodeInstanceLogMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	created_at            *int64
	addcreated_at         *int64
	updated_at            *int64
	addupdated_at         *int64
	deleted_at            *int64
	adddeleted_at         *int64
	flow_instance_id      *string
	flow_node_instance_id *string
	flow_instance_data_id *string
	node_key              *string
	_type                 *int8
	add_type              *int8
	status                *int8
	addstatus             *int8
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*FlowNodeInstanceLog, error)
	predicates            []predicate.FlowNodeInstanceLog
}

var _ ent.Mutation = (*FlowNodeInstanceLogMutation)(nil)

// flownodeinstancelogOption allows management of the mutation configuration using functional options.
type flownodeinstancelogOption func(*FlowNodeInstanceLogMutation)

// newFlowNodeInstanceLogMutation creates new mutation for the FlowNodeInstanceLog entity.
func newFlowNodeInstanceLogMutation(c config, op Op, opts ...flownodeinstancelogOption) *FlowNodeInstanceLogMutation {
	m := &FlowNodeInstanceLogMutation{
		config:        c,
		op:            op,
		typ:           TypeFlowNodeInstanceLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFlowNodeInstanceLogID sets the ID field of the mutation.
func withFlowNodeInstanceLogID(id string) flownodeinstancelogOption {
	return func(m *FlowNodeInstanceLogMutation) {
		var (
			err   error
			once  sync.Once
			value *FlowNodeInstanceLog
		)
		m.oldValue = func(ctx context.Context) (*FlowNodeInstanceLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FlowNodeInstanceLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFlowNodeInstanceLog sets the old FlowNodeInstanceLog of the mutation.
func withFlowNodeInstanceLog(node *FlowNodeInstanceLog) flownodeinstancelogOption {
	return func(m *FlowNodeInstanceLogMutation) {
		m.oldValue = func(context.Context) (*FlowNodeInstanceLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FlowNodeInstanceLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FlowNodeInstanceLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FlowNodeInstanceLog entities.
func (m *FlowNodeInstanceLogMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FlowNodeInstanceLogMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FlowNodeInstanceLogMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FlowNodeInstanceLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FlowNodeInstanceLogMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FlowNodeInstanceLogMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FlowNodeInstanceLog entity.
// If the FlowNodeInstanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowNodeInstanceLogMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *FlowNodeInstanceLogMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *FlowNodeInstanceLogMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FlowNodeInstanceLogMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FlowNodeInstanceLogMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FlowNodeInstanceLogMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FlowNodeInstanceLog entity.
// If the FlowNodeInstanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowNodeInstanceLogMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *FlowNodeInstanceLogMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *FlowNodeInstanceLogMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FlowNodeInstanceLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FlowNodeInstanceLogMutation) SetDeletedAt(i int64) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FlowNodeInstanceLogMutation) DeletedAt() (r int64, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FlowNodeInstanceLog entity.
// If the FlowNodeInstanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowNodeInstanceLogMutation) OldDeletedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *FlowNodeInstanceLogMutation) AddDeletedAt(i int64) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *FlowNodeInstanceLogMutation) AddedDeletedAt() (r int64, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FlowNodeInstanceLogMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
	m.clearedFields[flownodeinstancelog.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FlowNodeInstanceLogMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[flownodeinstancelog.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FlowNodeInstanceLogMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
	delete(m.clearedFields, flownodeinstancelog.FieldDeletedAt)
}

// SetFlowInstanceID sets the "flow_instance_id" field.
func (m *FlowNodeInstanceLogMutation) SetFlowInstanceID(s string) {
	m.flow_instance_id = &s
}

// FlowInstanceID returns the value of the "flow_instance_id" field in the mutation.
func (m *FlowNodeInstanceLogMutation) FlowInstanceID() (r string, exists bool) {
	v := m.flow_instance_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowInstanceID returns the old "flow_instance_id" field's value of the FlowNodeInstanceLog entity.
// If the FlowNodeInstanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowNodeInstanceLogMutation) OldFlowInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowInstanceID: %w", err)
	}
	return oldValue.FlowInstanceID, nil
}

// ResetFlowInstanceID resets all changes to the "flow_instance_id" field.
func (m *FlowNodeInstanceLogMutation) ResetFlowInstanceID() {
	m.flow_instance_id = nil
}

// SetFlowNodeInstanceID sets the "flow_node_instance_id" field.
func (m *FlowNodeInstanceLogMutation) SetFlowNodeInstanceID(s string) {
	m.flow_node_instance_id = &s
}

// FlowNodeInstanceID returns the value of the "flow_node_instance_id" field in the mutation.
func (m *FlowNodeInstanceLogMutation) FlowNodeInstanceID() (r string, exists bool) {
	v := m.flow_node_instance_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowNodeInstanceID returns the old "flow_node_instance_id" field's value of the FlowNodeInstanceLog entity.
// If the FlowNodeInstanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowNodeInstanceLogMutation) OldFlowNodeInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowNodeInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowNodeInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowNodeInstanceID: %w", err)
	}
	return oldValue.FlowNodeInstanceID, nil
}

// ResetFlowNodeInstanceID resets all changes to the "flow_node_instance_id" field.
func (m *FlowNodeInstanceLogMutation) ResetFlowNodeInstanceID() {
	m.flow_node_instance_id = nil
}

// SetFlowInstanceDataID sets the "flow_instance_data_id" field.
func (m *FlowNodeInstanceLogMutation) SetFlowInstanceDataID(s string) {
	m.flow_instance_data_id = &s
}

// FlowInstanceDataID returns the value of the "flow_instance_data_id" field in the mutation.
func (m *FlowNodeInstanceLogMutation) FlowInstanceDataID() (r string, exists bool) {
	v := m.flow_instance_data_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowInstanceDataID returns the old "flow_instance_data_id" field's value of the FlowNodeInstanceLog entity.
// If the FlowNodeInstanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowNodeInstanceLogMutation) OldFlowInstanceDataID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowInstanceDataID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowInstanceDataID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowInstanceDataID: %w", err)
	}
	return oldValue.FlowInstanceDataID, nil
}

// ClearFlowInstanceDataID clears the value of the "flow_instance_data_id" field.
func (m *FlowNodeInstanceLogMutation) ClearFlowInstanceDataID() {
	m.flow_instance_data_id = nil
	m.clearedFields[flownodeinstancelog.FieldFlowInstanceDataID] = struct{}{}
}

// FlowInstanceDataIDCleared returns if the "flow_instance_data_id" field was cleared in this mutation.
func (m *FlowNodeInstanceLogMutation) FlowInstanceDataIDCleared() bool {
	_, ok := m.clearedFields[flownodeinstancelog.FieldFlowInstanceDataID]
	return ok
}

// ResetFlowInstanceDataID resets all changes to the "flow_instance_data_id" field.
func (m *FlowNodeInstanceLogMutation) ResetFlowInstanceDataID() {
	m.flow_instance_data_id = nil
	delete(m.clearedFields, flownodeinstancelog.FieldFlowInstanceDataID)
}

// SetNodeKey sets the "node_key" field.
func (m *FlowNodeInstanceLogMutation) SetNodeKey(s string) {
	m.node_key = &s
}

// NodeKey returns the value of the "node_key" field in the mutation.
func (m *FlowNodeInstanceLogMutation) NodeKey() (r string, exists bool) {
	v := m.node_key
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeKey returns the old "node_key" field's value of the FlowNodeInstanceLog entity.
// If the FlowNodeInstanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowNodeInstanceLogMutation) OldNodeKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeKey: %w", err)
	}
	return oldValue.NodeKey, nil
}

// ResetNodeKey resets all changes to the "node_key" field.
func (m *FlowNodeInstanceLogMutation) ResetNodeKey() {
	m.node_key = nil
}

// SetType sets the "type" field.
func (m *FlowNodeInstanceLogMutation) SetType(i int8) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *FlowNodeInstanceLogMutation) GetType() (r int8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the FlowNodeInstanceLog entity.
// If the FlowNodeInstanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowNodeInstanceLogMutation) OldType(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *FlowNodeInstanceLogMutation) AddType(i int8) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *FlowNodeInstanceLogMutation) AddedType() (r int8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *FlowNodeInstanceLogMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetStatus sets the "status" field.
func (m *FlowNodeInstanceLogMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *FlowNodeInstanceLogMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the FlowNodeInstanceLog entity.
// If the FlowNodeInstanceLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowNodeInstanceLogMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *FlowNodeInstanceLogMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *FlowNodeInstanceLogMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *FlowNodeInstanceLogMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// Where appends a list predicates to the FlowNodeInstanceLogMutation builder.
func (m *FlowNodeInstanceLogMutation) Where(ps ...predicate.FlowNodeInstanceLog) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FlowNodeInstanceLogMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FlowNodeInstanceLog).
func (m *FlowNodeInstanceLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FlowNodeInstanceLogMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, flownodeinstancelog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, flownodeinstancelog.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, flownodeinstancelog.FieldDeletedAt)
	}
	if m.flow_instance_id != nil {
		fields = append(fields, flownodeinstancelog.FieldFlowInstanceID)
	}
	if m.flow_node_instance_id != nil {
		fields = append(fields, flownodeinstancelog.FieldFlowNodeInstanceID)
	}
	if m.flow_instance_data_id != nil {
		fields = append(fields, flownodeinstancelog.FieldFlowInstanceDataID)
	}
	if m.node_key != nil {
		fields = append(fields, flownodeinstancelog.FieldNodeKey)
	}
	if m._type != nil {
		fields = append(fields, flownodeinstancelog.FieldType)
	}
	if m.status != nil {
		fields = append(fields, flownodeinstancelog.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FlowNodeInstanceLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flownodeinstancelog.FieldCreatedAt:
		return m.CreatedAt()
	case flownodeinstancelog.FieldUpdatedAt:
		return m.UpdatedAt()
	case flownodeinstancelog.FieldDeletedAt:
		return m.DeletedAt()
	case flownodeinstancelog.FieldFlowInstanceID:
		return m.FlowInstanceID()
	case flownodeinstancelog.FieldFlowNodeInstanceID:
		return m.FlowNodeInstanceID()
	case flownodeinstancelog.FieldFlowInstanceDataID:
		return m.FlowInstanceDataID()
	case flownodeinstancelog.FieldNodeKey:
		return m.NodeKey()
	case flownodeinstancelog.FieldType:
		return m.GetType()
	case flownodeinstancelog.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FlowNodeInstanceLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flownodeinstancelog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case flownodeinstancelog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case flownodeinstancelog.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case flownodeinstancelog.FieldFlowInstanceID:
		return m.OldFlowInstanceID(ctx)
	case flownodeinstancelog.FieldFlowNodeInstanceID:
		return m.OldFlowNodeInstanceID(ctx)
	case flownodeinstancelog.FieldFlowInstanceDataID:
		return m.OldFlowInstanceDataID(ctx)
	case flownodeinstancelog.FieldNodeKey:
		return m.OldNodeKey(ctx)
	case flownodeinstancelog.FieldType:
		return m.OldType(ctx)
	case flownodeinstancelog.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown FlowNodeInstanceLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlowNodeInstanceLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flownodeinstancelog.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case flownodeinstancelog.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case flownodeinstancelog.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case flownodeinstancelog.FieldFlowInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowInstanceID(v)
		return nil
	case flownodeinstancelog.FieldFlowNodeInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowNodeInstanceID(v)
		return nil
	case flownodeinstancelog.FieldFlowInstanceDataID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowInstanceDataID(v)
		return nil
	case flownodeinstancelog.FieldNodeKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeKey(v)
		return nil
	case flownodeinstancelog.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case flownodeinstancelog.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown FlowNodeInstanceLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FlowNodeInstanceLogMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, flownodeinstancelog.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, flownodeinstancelog.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, flownodeinstancelog.FieldDeletedAt)
	}
	if m.add_type != nil {
		fields = append(fields, flownodeinstancelog.FieldType)
	}
	if m.addstatus != nil {
		fields = append(fields, flownodeinstancelog.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FlowNodeInstanceLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case flownodeinstancelog.FieldCreatedAt:
		return m.AddedCreatedAt()
	case flownodeinstancelog.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case flownodeinstancelog.FieldDeletedAt:
		return m.AddedDeletedAt()
	case flownodeinstancelog.FieldType:
		return m.AddedType()
	case flownodeinstancelog.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlowNodeInstanceLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case flownodeinstancelog.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case flownodeinstancelog.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case flownodeinstancelog.FieldDeletedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case flownodeinstancelog.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case flownodeinstancelog.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown FlowNodeInstanceLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FlowNodeInstanceLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(flownodeinstancelog.FieldDeletedAt) {
		fields = append(fields, flownodeinstancelog.FieldDeletedAt)
	}
	if m.FieldCleared(flownodeinstancelog.FieldFlowInstanceDataID) {
		fields = append(fields, flownodeinstancelog.FieldFlowInstanceDataID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FlowNodeInstanceLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FlowNodeInstanceLogMutation) ClearField(name string) error {
	switch name {
	case flownodeinstancelog.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case flownodeinstancelog.FieldFlowInstanceDataID:
		m.ClearFlowInstanceDataID()
		return nil
	}
	return fmt.Errorf("unknown FlowNodeInstanceLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FlowNodeInstanceLogMutation) ResetField(name string) error {
	switch name {
	case flownodeinstancelog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case flownodeinstancelog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case flownodeinstancelog.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case flownodeinstancelog.FieldFlowInstanceID:
		m.ResetFlowInstanceID()
		return nil
	case flownodeinstancelog.FieldFlowNodeInstanceID:
		m.ResetFlowNodeInstanceID()
		return nil
	case flownodeinstancelog.FieldFlowInstanceDataID:
		m.ResetFlowInstanceDataID()
		return nil
	case flownodeinstancelog.FieldNodeKey:
		m.ResetNodeKey()
		return nil
	case flownodeinstancelog.FieldType:
		m.ResetType()
		return nil
	case flownodeinstancelog.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown FlowNodeInstanceLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FlowNodeInstanceLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FlowNodeInstanceLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FlowNodeInstanceLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FlowNodeInstanceLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FlowNodeInstanceLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FlowNodeInstanceLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FlowNodeInstanceLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FlowNodeInstanceLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FlowNodeInstanceLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FlowNodeInstanceLog edge %s", name)
}
